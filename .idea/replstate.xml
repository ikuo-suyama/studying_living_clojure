<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="ReplState" timestamp="1438062805515">{:repl-history {:ide [], :local [&quot;(defn combine-string-with-recur [target-list]\n  (if (empty? target-list)\n    \&quot; \&quot;\n    ((first target-list)\n    (recur (rest target-list)))))&quot; &quot;(defn combine-string-with-recur [target-list]\n  ((if (empty? target-list)\n    \&quot; \&quot;\n    (first target-list))\n    (recur (rest target-list))))&quot; &quot;(defn combine-string-with-recur [target-list]\n  (if (empty? target-list)\n    \&quot; \&quot;\n    (first target-list))\n    )&quot; &quot;(defn combine-string-with-recur [target-list]\n  (if (empty? target-list)\n    \&quot; \&quot;\n    (recur ((first target-list) (rest target-list))))\n    )&quot; &quot;(defn combine-string-with-recur [target-list]\n  (if (empty? target-list)\n    \&quot; \&quot;\n    (recur ((first target-list) (rest target-list)))))&quot; &quot;(defn combine-string-with-recur [target-list]\n  (if (empty? target-list)\n    \&quot; \&quot;\n    (recur (rest target-list))))&quot; &quot;(combine-string-with-recur [\&quot;test1\&quot; \&quot;test2\&quot; \&quot;test3\&quot;])&quot; &quot;(map fn [target] (str taret) animals )&quot; &quot;fn [target] (str taret)&quot; &quot;(def animals [:mouse :duc :dodo :lory :eaglet])&quot; &quot;(map (fn [target] (str taret)) animals)&quot; &quot;(map (fn [target] (str target)) animals)&quot; &quot;(take 5 (map #(str %) (cycle animals)))&quot; &quot;(take 10 (map #(str %) (cycle animals)))&quot; &quot;(map #(println %) [1 3 4 5 6])&quot; &quot;(map fn [x y](str x \&quot;_\&quot; y) [1 2 4 5] [10 11 12])&quot; &quot;(map (fn [x y](str x \&quot;_\&quot; y)) [1 2 4 5] [10 11 12])&quot; &quot;(map (fn [x y](str x \&quot;_\&quot; y)) [1 2 4 5] (cycle [10 11]))&quot; &quot;(reduce + [1 2 3 4 5])&quot; &quot;(reduce (fn [r x]\n          (if (nil? x)\n            r\n            (ocnj r x))))&quot; &quot;(reduce (fn [r x]\n          (if (nil? x)\n            r\n            (conj r x))) [:fuck nil :fuck nil])&quot; &quot;(reduce (fn [r x]\n          (if (nil? x)\n            r\n            (conj r x)))\n        []\n        [:fuck nil :fuck nil])&quot; &quot;(reduce (fn [r x] (str r x)) [\&quot;a\&quot; \&quot;b\&quot; \&quot;c\&quot;])&quot; &quot;doc complement&quot; &quot;(doc complement\n     )&quot; &quot;(reduce (fn [r x] (str r \&quot;_\&quot; x)) [\&quot;a\&quot; \&quot;b\&quot; \&quot;c\&quot;])&quot; &quot;(filetr (complement nil?) [:test nil :test2 nil])&quot; &quot;(filter (complement nil?) [:test nil :test2 nil])&quot; &quot;(remove nil? [:test nil :test2 nil])&quot; &quot;(for [animal [:mouse :duck :lory]]\n  (str (name animal)))&quot; &quot;(for [animal [:mouse :duck :lory]\n      color [:red :blue]]\n  (Str (name animal) (name color)))&quot; &quot;(for [animal [:mouse :duck :lory]\n      color [:red :blue]]\n  (str (name animal) (name color)))&quot; &quot;(for [i (take 5 (range))\n      j (take 4 (range))]\n  (* i j))&quot; &quot;(take 5 (range))&quot; &quot;(for [i (take 5 (range))\n      j (take 4 (range))]\n  (+ i j))&quot; &quot;(for [i (take 5 (range))\n      j (take 4 (range))]\n  (str i \&quot;_\&quot; j))&quot; &quot;(for [animal [:mouse :duck :lory]\n      color [:red :blue]\n  :let [animal-str (str \&quot;animal-\&quot; (name animal))\n        color-str (str \&quot;color-\&quot; (name color))]\n  :when (= color :blue)]\n  (str animal-str \&quot;_\&quot; color-str))&quot; &quot;(partition-all 3 [1 2 3 4 5 6 7 8 9 10])&quot; &quot;'(1 2 \&quot;jam\&quot;)&quot; &quot;(cons 4 5)&quot; &quot;(cons 4 nil)&quot; &quot;(:key1 {:key1 \&quot;test\&quot; :key2 \&quot;test2\&quot;})&quot; &quot;(assoc {:key1 \&quot;test\&quot; :key2 \&quot;test\&quot;} :key1 \&quot;value\&quot;)&quot; &quot;(deftest a-test\n  (testing \&quot;FIXME, I fail.\&quot;\n    (is (= 0 1))))&quot; &quot;test&quot; &quot;run-test&quot; &quot;run-testts&quot; &quot;run-test s&quot; &quot;run-tests&quot; &quot;(run-tests)&quot; &quot;(run-tests\n  )&quot; &quot;(deftest a-test\n  (testing \&quot;FIXME, I fail.\&quot;\n    (is (= 1 1))))&quot; &quot;(deftest a-test\n  (testing \&quot;sample-function return 'test'\&quot;\n    (is (= (sample-function) \&quot;test\&quot;))))&quot; &quot;(test-filtered [1 2 3 4])&quot; &quot;(deftest test-a-function\n  (testing \&quot;the function should return filtered value\&quot;\n    (is (= 1 1))))&quot; &quot;(defn foo [] (\&quot;Hello\&quot;))&quot; &quot;(defn bar [] ((str (foo) \&quot; World\&quot;)))&quot; &quot;(defn bar [] ((str foo \&quot; World\&quot;)))&quot; &quot;(bar)&quot; &quot;(defn- foo [] \&quot;Hello\&quot;)&quot; &quot;(defn bar [] (str (foo) \&quot; World\&quot;))&quot; &quot;(ns test-another-namespace)&quot; &quot;(test-private-func/bar)&quot; &quot;(test-private-func/foo)&quot; &quot;(who-atom)&quot; &quot;(@who-atom)&quot; &quot;(print @who-atom)&quot; &quot;(print who-atom)&quot; &quot;@who-atom&quot; &quot;(reset! who-atom :chrysalis)&quot; &quot;(def who-atom (atom :caterpillar))&quot; &quot;(swap! who-atom change)&quot; &quot;(def count (atom 0))&quot; &quot;(dotime [_ 5] (swap! counter inc))&quot; &quot;dotimes&quot; &quot;(dotimes [_ 5] (swap! counter inc))&quot; &quot;@counter&quot; &quot;(def counter (atom 0))&quot; &quot;(let [n 10]\n  (future (dotimes [_ n] counter inc-print))\n  (future (dotimes [_ n] counter inc-print))\n  (future (dotimes [_ n] counter inc-print))\n  )&quot; &quot;(defn inc-print\n  [val]\n  (print val)\n  (inc val))&quot; &quot;(defn inc-print\n  [val]\n  (println val)\n  (inc val))&quot; &quot;(let [n 10]\n  (future (dotimes [_ n] (swap! counter inc-print)))\n  (future (dotimes [_ n] (swap! counter inc-print)))\n  (future (dotimes [_ n] {(swap! counter inc-print)}))\n  )&quot; &quot;(let [n 10]\n  (future (dotimes [_ n] (swap! counter inc-print)))\n  (future (dotimes [_ n] (swap! counter inc-print)))\n  (future (dotimes [_ n] (swap! counter inc-print)))\n  )&quot; &quot;(defn eat-from-right-hand []\n  (when (pos? @right-hand-bites)\n    (alter right-hand-bites dec)\n    (alter alice-height #(+ % 24))))&quot; &quot;(eat-from-right-hand)&quot; &quot;(dosync (eat-from-right-hand))&quot; &quot;(let [n 10]\n  (future (dotimes [_ n] (eat-from-right-hand)))\n  (future (dotimes [_ n] (eat-from-right-hand)))\n  (future (dotimes [_ n] (eat-from-right-hand))))&quot; &quot;(let [n 10]\n  (future (dotimes [_ n] (eat-from-right-hand-sync)))\n  (future (dotimes [_ n] (eat-from-right-hand-sync)))\n  (future (dotimes [_ n] (eat-from-right-hand-sync))))&quot; &quot;(defn eat-from-right-hand-sync []\n  (dosync (when (pos? @right-hand-bites)\n    (alter right-hand-bites dec)\n    (alter alice-height #(+ % 24)))))&quot; &quot;(def alice-height (ref 3))&quot; &quot;(def right-hand-bites (ref 10))&quot; &quot;(let [n 3]\n  (future (dotimes [_ n] (eat-from-right-hand-sync)))\n  (future (dotimes [_ n] (eat-from-right-hand-sync)))\n  (future (dotimes [_ n] (eat-from-right-hand-sync))))&quot; &quot;@right-hand-bites&quot; &quot;(defn chnage [state]\n  (case state\n    :caterpillar :chysalis\n    :chysalis :butterfly\n    :butterfly :deadbody))&quot; &quot;(send-off who-agent change)&quot; &quot;@who-agent&quot; &quot;(defn change-error [state]\n  (throw (Exception. \&quot;Error!!\&quot;)))&quot; &quot;(def who-agent (agent :caterpillar))&quot; &quot;(send who-agent change-error)&quot; &quot;(send who-agent change)&quot; &quot;&quot;], :remote []}}</component>
</project>