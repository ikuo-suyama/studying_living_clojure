<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="ReplState" timestamp="1437010189822">{:repl-history {:ide [], :local [&quot;*ns*&quot; &quot;(not nil)&quot; &quot;(= :drink :drink)&quot; &quot;(= '(:test :test2) [:test :test])&quot; &quot;(= '(:test :test2) [:test :test2])&quot; &quot;(not= :test 1)&quot; &quot;(seq [1 2 3])&quot; &quot;(class (seq [1 2 3]))&quot; &quot;(source empty?)&quot; &quot;(every? odd? [1 3 5])&quot; &quot;(not-any? odd? [2 5])&quot; &quot;(not-any? odd? [1 5])&quot; &quot;(not-any? odd? [2 4])&quot; &quot;(some fn [] (&lt; 3) [1 2 3 4 5])&quot; &quot;(some (fn [] (&lt; 3)) [1 2 3 4 5])&quot; &quot;(some (fn [x] (&lt; x 3)) [1 2 3 4 5])&quot; &quot;(some #{3} {1 2 2 3 4})&quot; &quot;(some #{3} [1 2 2 3 4])&quot; &quot;(some #{3} [1 2 2 4 4])&quot; &quot;(some #{3} [1 2 2 4 3 4])&quot; &quot;#{3 4}&quot; &quot;(some #{4 3} [1 2 2 4 3 4])&quot; &quot;(some #{4 3 5} [1 2 2 4 3 4])&quot; &quot;(some #{5 3 5} [1 2 2 4 3 4])&quot; &quot;(some #{5 3} [1 2 2 4 3 4])&quot; &quot;(some #{5 6} [1 2 2 4 3 4])&quot; &quot;(some #{4 2} [1 2 2 4 3 4])&quot; &quot;(if (= :drinkme :drinkme)\n  \&quot;Fucked Up!\&quot;\n  \&quot;Dont try it\&quot;)&quot; &quot;(let [try-drink (= :drinkme :drinkme)]\n  (if try-drink\n    \&quot;Fucked Up!\&quot;\n    \&quot;Dont try it\&quot;))&quot; &quot;(if-let [try-drink (= :drinkme :drinkme)]\n        \&quot;Fucked Up!\&quot;\n        \&quot;Dont try it\&quot;)\n&quot; &quot;(when-let [would_you_driknk false]\n  \&quot;Fucked Up\&quot;\n  \&quot;Dont try it\&quot;)&quot; &quot;(let [bottle \&quot;drinkme\&quot;]\n  (cond\n    (= bottle \&quot;poison\&quot;)  \&quot;dont touch\&quot;\n    (= bottle \&quot;drinkme\&quot;) \&quot;Fucked Up\&quot;))&quot; &quot;(let [bottle \&quot;what else\&quot;]\n  (cond\n    (= bottle \&quot;poison\&quot;)  \&quot;dont touch\&quot;\n    (= bottle \&quot;drinkme\&quot;) \&quot;Fucked Up\&quot;)\n    :else \&quot;OMG\&quot;)&quot; &quot;(let [bottle = \&quot;test\&quot;]\n  (case\n    \&quot;check\&quot; \&quot;no\&quot;\n            \&quot;test\&quot; \&quot;ok\&quot;))\n&quot; &quot;(let [bottle = \&quot;test\&quot;]\n  (case bottle\n    \&quot;check\&quot; \&quot;no\&quot;\n    \&quot;test\&quot; \&quot;ok\&quot;))&quot; &quot;(let [bottle \&quot;test\&quot;]\n  (case bottle\n    \&quot;check\&quot; \&quot;no\&quot;\n    \&quot;test\&quot; \&quot;ok\&quot;))&quot; &quot;(defn grow [name direction]\n  (if (= direction :small)\n    name \&quot;is growing smaller\&quot;\n    name \&quot;is growing bigger\&quot;))&quot; &quot;(defn grow [name direction]\n  (if (= direction :small)\n    (name \&quot;is growing smaller\&quot;)\n    (name \&quot;is growing bigger\&quot;)))&quot; &quot;(grew \&quot;Alice\&quot; :small)&quot; &quot;(defn grow [name direction]\n  (if (= direction :small)\n    (str name \&quot;is growing smaller\&quot;)\n    (str name \&quot;is growing bigger\&quot;)))&quot; &quot;(grow \&quot;Alice\&quot; :small)&quot; &quot;((partial grow \&quot;Alice\&quot;) :small)&quot; &quot;(defn toggle-grow [direction]\n  (if (=d irection :small) :small :big))&quot; &quot;(defn toggle-grow [direction]\n  (if (= direction :small) :small :big))&quot; &quot;(defn toggle-grow [direction]\n  (if (= direction :small) :big :small))&quot; &quot;(defn comb-grow [direction]\n  ((comb grow toggle-grow) direction))&quot; &quot;(defn comb-grow [direction]\n  ((comp grow toggle-grow) direction))&quot; &quot;(defn comp-grow [direction]\n  ((comp grow toggle-grow) direction))&quot; &quot;(defn comp-grow [direction]\n  ((comp (partial grow \&quot;Alice\&quot;) toggle-grow) direction))&quot; &quot;(comp-grow :small)&quot; &quot;(let [[[color size] :as :original] [\&quot;blue\&quot; \&quot;small\&quot;]]\n  (str \&quot;the \&quot; color \&quot; door is \&quot; size :original))&quot; &quot;(let [[[color size] :as original] [\&quot;blue\&quot; \&quot;small\&quot;]]\n  (str \&quot;the \&quot; color \&quot; door is \&quot; size original))&quot; &quot;(let [[color size] :as original [\&quot;blue\&quot; \&quot;small\&quot;]]\n  (str \&quot;the \&quot; color \&quot; door is \&quot; size original))&quot; &quot;(let [[color size] [\&quot;blue\&quot; \&quot;small\&quot;]]\n  (str \&quot;the \&quot; color \&quot; door is \&quot; size))&quot; &quot;(let [x [\&quot;blue small\&quot;]\n      (color (first x))\n      (size (lastx))]\n  {:color color :size size})&quot; &quot;(let [x [\&quot;blue small\&quot;]\n      color (first x)\n      size (lastx)]\n  {:color color :size size})&quot; &quot;(let [x [\&quot;blue small\&quot;]\n      color (first x)\n      size (last x)]\n  {:color color :size size})&quot; &quot;(let [x [\&quot;blue\&quot; \&quot;small\&quot;]\n      color (first x)\n      size (last x)]\n  {:color color :size size})&quot; &quot;(let [{flower :flower1 flower2 :flower2}\n      {:flower \&quot;test1\&quot; :flower2 \&quot;test2\&quot;}]\n  str flower flower2)&quot; &quot;(let [{flower :flower1 flower2 :flower2}\n      {:flower \&quot;test1\&quot; :flower2 \&quot;test2\&quot;}]\n  (str flower flower2))&quot; &quot;(let [{flower :flower1 flower2 :flower2}\n      {:flower1 \&quot;test1\&quot; :flower2 \&quot;test2\&quot;}]\n  (str flower flower2))&quot; &quot;(let [{flower :flower1 flower2 :flower2}\n      {:flower1 \&quot;test1\&quot; :flower2 \&quot;test2\&quot;}]\n  (str flower \&quot; !!\&quot; flower2))&quot; &quot;(let [{flower :flower1 flower2 :flower2}\n      {:flower1 \&quot;test1\&quot; :flower2 \&quot;test2\&quot;}]\n  (str flower \&quot; !! \&quot; flower2))&quot; &quot;(let [{flower :flower1 flower2 :flower2 flower3 :flower3 :or {flower3 \&quot;missing\&quot;}}\n      {:flower1 \&quot;blue\&quot; :flower2 \&quot;red\&quot;}]\n  (str flower \&quot; !! \&quot; flower2 \&quot; \&quot; flower3 ))&quot; &quot;(let [{flower :flower1 flower2 :flower2 flower3 :flower3 :or {flower3 \&quot;missing\&quot;} :as whole-flowers}\n      {:flower1 \&quot;blue\&quot; :flower2 \&quot;red\&quot;}]\n  (str flower \&quot; !! \&quot; flower2 \&quot; \&quot; flower3))&quot; &quot;(let [{flower :flower1 flower2 :flower2 flower3 :flower3 :or {flower3 \&quot;missing\&quot;} :as whole-flowers}\n      {:flower1 \&quot;blue\&quot; :flower2 \&quot;red\&quot;}]\n  (str flower \&quot; !! \&quot; flower2 \&quot; \&quot; flower3 \&quot; \&quot; whole-flowers))&quot; &quot;(defn flower-colors [{:keys [:flower1 :flower2]}]\n  (str \&quot;The flowers are \&quot; flower1 \&quot; and \&quot; flower2))&quot; &quot;(defn flower-colors [{:keys [flower1 flower]}]\n  (str \&quot;The flowers are \&quot; flower1 \&quot; and \&quot; flower))&quot; &quot;(defn flower-colors [{:keys [flower1 flower2]}]\n  (str \&quot;The flowers are \&quot; flower1 \&quot; and \&quot; flower2))&quot; &quot;(flower-colors {:flower1 \&quot;red\&quot; :flower2 \&quot;blue\&quot;})&quot; &quot;(let [{:keys [flower1 flower2]}\n      {:flower1 \&quot;red\&quot; :flower2 \&quot;blue\&quot;}]\n  (str \&quot;The flowers are \&quot; flower1 \&quot; and \&quot; flower2))&quot; &quot;(let [{flower1 :flower1 flower2 :flower2}\n      {:flower1 \&quot;red\&quot; :flower2 \&quot;blue\&quot;}]\n  (str \&quot;The flowers are \&quot; flower1 \&quot; and \&quot; flower2))&quot; &quot;(let [:keys {param1 param2 param3 param4}\n      {:param1 \&quot;test1\&quot; :param2 \&quot;test2\&quot;}\n      :or {param3 \&quot;test3\&quot; param4 \&quot;test4\&quot;}]\n  ((map #(str % \&quot; \&quot;) [param1 param2 param3 param4])))&quot; &quot;(let [[:keys {param1 param2 param3 param4}\n       :or {param3 \&quot;test3\&quot; param4 \&quot;test4\&quot;}]\n      {:param1 \&quot;test1\&quot; :param2 \&quot;test2\&quot;}]\n  ((map #(str % \&quot; \&quot;) [param1 param2 param3 param4])))&quot; &quot;(let [{:keys [param1 param2 param3 param4]}\n       :or {param3 \&quot;test3\&quot; param4 \&quot;test4\&quot;}\n      {:param1 \&quot;test1\&quot; :param2 \&quot;test2\&quot;}]\n  ((map #(str % \&quot; \&quot;) [param1 param2 param3 param4])))&quot; &quot;(let [{:keys [param1 param2 param3 param4]}\n       :or {param3 \&quot;test3\&quot; param4 \&quot;test4\&quot;}\n      {:param1 \&quot;test1\&quot; :param2 \&quot;test2\&quot;}]\n  (str param1 param2 param3 param4))&quot; &quot;(let [{:keys [param1 param2 param3 param4]}\n       ;:or {param3 \&quot;test3\&quot; param4 \&quot;test4\&quot;}\n      {:param1 \&quot;test1\&quot; :param2 \&quot;test2\&quot;}]\n  (str param1 param2 param3 param4))&quot; &quot;(let [{:keys [param1 param2 param3 param4]:or {param3 \&quot;test3\&quot; param4 \&quot;test4\&quot;}}\n      {:param1 \&quot;test1\&quot; :param2 \&quot;test2\&quot;}]\n  (str param1 param2 param3 param4))&quot; &quot;(let [{:keys [param1 param2 param3 param4]\n       :or   {param3 \&quot;test3\&quot; param4 \&quot;test4\&quot;}}\n      {:param1 \&quot;test1\&quot; :param2 \&quot;test2\&quot;}]\n  ((map #(str % \&quot; \&quot;) [param1 param2 param3 param4])))&quot; &quot;(let [{:keys [param1 param2 param3 param4]\n       :or   {param3 \&quot;test3\&quot; param4 \&quot;test4\&quot;}}\n      {:param1 \&quot;test1\&quot; :param2 \&quot;test2\&quot;}]\n  ([param1 param2 param3 param4]))&quot; &quot;(let [{:keys [param1 param2 param3 param4]\n       :or   {param3 \&quot;test3\&quot; param4 \&quot;test4\&quot;}}\n      {:param1 \&quot;test1\&quot; :param2 \&quot;test2\&quot;}]\n  (join \&quot; \&quot; [param1 param2 param3 param4]))&quot; &quot;(let [{:keys [param1 param2 param3 param4]\n       :or   {param3 \&quot;test3\&quot; param4 \&quot;test4\&quot;}}\n      {:param1 \&quot;test1\&quot; :param2 \&quot;test2\&quot;}]\n  (clojure.string/join \&quot; \&quot; [param1 param2 param3 param4]))&quot; &quot;(take 5 (range))&quot; &quot;(class (range 5))&quot; &quot;(take 5 (repeat \&quot;test\&quot;))&quot; &quot;(take 10 (repeat (rand-int 10)))&quot; &quot;(take 10 (repeatedly (rand-int 10)))&quot; &quot;(take 10 (repeatedly #(rand-int 10)))&quot; &quot;(take 20 (rest (cycle [\&quot;test1\&quot; \&quot;test2\&quot;])))&quot; &quot;(def adjs [\&quot;normal\&quot;\n           \&quot;too small\&quot;\n           \&quot;too big\&quot;\n           \&quot;is swiming\&quot;])&quot; &quot;(defn alise-is [in out]\n  (if (empty? in)\n    out\n    (alise-is\n      (rest in)\n      (conj out\n            (str Alice is (first in))))))&quot; &quot;(defn alise-is [in out]\n  (if (empty? in)\n    out\n    (alise-is\n      (rest in)\n      (conj out\n            (str \&quot;Alice is\&quot; (first in))))))&quot; &quot;(defn alise-is [in out]\n  (if (empty? in)\n    out\n    (alise-is\n      (rest in)\n      (conj out\n            (str \&quot;Alice is \&quot; (first in))))))&quot; &quot;(alise-is adjs [])&quot; &quot;(defn alice-is-with-loop [input]\n  (loop [in input\n         out []]\n    (if (empty? in)\n      out\n      (recur (rest in)\n             (conj out\n                   (str \&quot;Alice is \&quot; (first in)))))))&quot; &quot;(alice-is-with-loop adjs)&quot; &quot;(defn recur-combine-string [comb-str target-list]\n  (fn ! [output recurring-list]\n    (if (empty? recurring-list)\n      output\n      (! (str comb-str (first recurring-list)) (rest recurring-list)))) \&quot;\&quot; target-list)&quot; &quot;(defn \&quot; \&quot; [\&quot;test1\&quot; \&quot;test2\&quot;])&quot; &quot;(defn recur-combine-string [comb-str target-list]\n  (fn rec [output recurring-list]\n    (if (empty? recurring-list)\n      output\n      (rec (str comb-str (first recurring-list))\n         (rest recurring-list))))\n  \&quot;\&quot; target-list)&quot; &quot;(defn recur-combine-string [comb-str target-list]\n  (fn ! [output recurring-list]\n    (if (empty? recurring-list)\n      output\n      (! (str comb-str (first recurring-list))\n         (rest recurring-list))))\n  \&quot;\&quot; target-list)&quot; &quot;(recur-combine-string \&quot; \&quot; [\&quot;test1\&quot; \&quot;test2\&quot;])&quot;], :remote []}}</component>
</project>